@using Namezr.Client.Infra
@using Namezr.Client.Studio.Questionnaires.Edit
@using SuperLinq
@using vNext.BlazorComponents.FluentValidation

@rendermode InteractiveWebAssembly

@inject ISpaHttpClientProvider HttpClientProvider

<EditForm Model="Values" OnValidSubmit="HandleValidSubmit">
    <FluentValidationValidator Validator="Validator"/>

    @foreach (QuestionnaireConfigFieldModel field in Config.Fields)
    {
        string fieldIdStr = field.Id.ToString();

        if (FieldValidatorProviders.TryGetValue(fieldIdStr, out FieldValidatorProvider? validatorProvider))
        {
            <FluentValidationValidator ValidatorFactory="validatorProvider"/>
        }

        <div class="my-3">
            @switch (field.Type)
            {
                case QuestionnaireFieldType.Text:
                    <HxInputText
                        Enabled="!AllDisabled"
                        LabelType="LabelType.Floating"
                        Label="@field.Title"
                        @bind-Value="Values[fieldIdStr].StringValue"
                    />
                    break;

                case QuestionnaireFieldType.Number:
                    <HxInputNumber
                        Enabled="!AllDisabled"
                        LabelType="LabelType.Floating"
                        Label="@field.Title"
                        @bind-Value="Values[fieldIdStr].NumberValue"
                    />
                    break;

                case QuestionnaireFieldType.FileUpload:
                    @*<HxInputFile/>*@
                    /* TODO: file upload */
                    break;

                default:
                    throw new ArgumentOutOfRangeException();
            }

            @if (!string.IsNullOrWhiteSpace(field.Description))
            {
                <div>
                    <pre>@field.Description</pre>
                </div>
            }
        </div>
    }

    <HxSubmit
        Enabled="!AllDisabled && RendererInfo.IsInteractive"
        Text="Submit"
        Color="@ThemeColor.Primary"
        Spinner="IsSending"
    />
</EditForm>

@code {

    [Parameter]
    public bool AllDisabled { get; set; }
    
    [Parameter]
    public required Guid QuestionnaireVersionId { get; init; }

    [Parameter]
    public required QuestionnaireConfigModel Config { get; init; }

    [Parameter]
    public Dictionary<string, SubmissionValueModel>? InitialValues { get; set; }
    
    [Parameter]
    public required Dictionary<Guid, string> FileUploadTickets { get; set; }

    private Dictionary<string, SubmissionValueModel> Values { get; } = new();

    /// <summary>
    /// <para>
    /// The <see cref="P:Microsoft.AspNetCore.Components.Forms.FieldChangedEventArgs.FieldIdentifier"/> that
    /// the validator(s) get "starts" with the <see cref="SubmissionValueModel"/> as the model
    /// so they cannot figure out the path from the root of the form.
    /// </para>
    /// <para>
    /// So we abuse <see cref="vNext.BlazorComponents.FluentValidation.IValidatorFactory"/> and the ability
    /// to register multiple validators for the same form to "supplement" the root validator.
    /// </para>
    /// </summary>
    // TODO: Create GH issues (with child enrolment example)- aspnet (Blazor), vNext.BlazorComponents.FluentValidation
    // TODO: FluentValidationValidator does not unsubscribe when removed
    private IReadOnlyDictionary<string, FieldValidatorProvider> FieldValidatorProviders { get; set; } = null!;

    private SubmissionValuesValidator<string> Validator { get; set; } = null!;

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        InitialValues?.DeepCloneInto(Values);

        // Delete values for fields which were removed from the questionnaire
        Values.Keys
            .Except(Config.Fields.Select(field => field.Id.ToString()))
            .ToArray()
            .ForEach(x => Values.Remove(x));

        // Ensure all values have an entry
        foreach (QuestionnaireConfigFieldModel field in Config.Fields)
        {
            Values.TryAdd(field.Id.ToString(), new SubmissionValueModel());
        }

        Validator = new SubmissionValuesValidator<string>(Config, x => x.ToString());
        FieldValidatorProviders = Validator.PerFieldValidators
            .ToDictionary(x => x.Key, x => new FieldValidatorProvider
            {
                Validator = x.Value,
                Model = Values[x.Key],
            });
    }

    private bool? IsSending { get; set; }

    private async Task HandleValidSubmit()
    {
        IsSending = true;
        try
        {
            await HttpClientProvider.HttpClient.PostAsJsonAsync(
                ApiEndpointPaths.QuestionnaireSubmissionSave,
                new SubmissionCreateModel
                {
                    QuestionnaireVersionId = QuestionnaireVersionId,
                    Values = Values.ToDictionary(x => Guid.Parse(x.Key), x => x.Value),
                }
            );
        }
        finally
        {
            IsSending = false;
            StateHasChanged();
        }
    }

}